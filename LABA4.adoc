= Отчет по лабораторной работе №4

== *Задание.*

Тактирование микроконтроллера осуществляется от  PLL источника на частоте равной 10 МГц
или близкой к ней. По нажатию кнопки изменить состояние 4 светодиодов на противоположные.
Нажатием кнопки считается разовое нажатие и отжатие кнопки.

== *_Выполнение задания:_*

----
1. Настроим тактирование микроконтроллера  от PLL источника частотой около 10 МГц.
----
* Включим внешний источник HSE.
-  Дожидаемся его готовности.
- Переключим на выбранный источник системную частоту.
- Дождемся переключения.
- Отключим
внутренний источник HSI.
- Переключим PLL на HSE , с помощью регистра PLLCFGR.
* Установим нужную частоту.
- Зная систему тактирования нашего
микроконтроллера, мы можем начать установку частоты с модуля НSE , который имеет
известную частоту равную 8 МГц.

 - Следуя схеме мы попадаем на делитель,в котором должны
преобразовать нашу частоту таким образом чтобы на модуле VCC её значение составило 2 или
1 МГц.
 - Разделим известную частоту на 4 и в итоге на модуль VCC попадает значение
2 МГц.
- Для получения заданного значения нужно умножить и разделить значение модуля
VCC на некоторые числа.
- Так как мы не смогли  настроить частоту ниже 15 МГц включительно.Взяли частоту равную 16,67 МГц.
- Для этого умножаем частоту на 50 получаем на выходе частоту 100
МГц.
- Данная частота является верной так как лежит в диапазоне от 100 до 432 МГц.
- Попадаем на делитель р, который может принимать значения 2, 4, 6, 8.
- Разделим 100 МГц на 6 и в
итоге получим частоту 16,67 МГц.
* Переключим системный источник на полученную
частоту.
- Дожидаемся, пока системная частота переключится на наш источник.

----
2.Подключим необходимые порты
----

* Подключим порты А и С к шине тактирования и переведем их в состояние Enable.

* Настроим ножку  GPIOC13 на вход
* Ножки GPIOC5, GPIOC8, GPIOC9 и GPIOА5 подключаются на выход.

----
3.Включение светодиодов
----

* Для коректной работы программы воспользуемся циклом while.
- Введем переменную flag, которая определяет кнопка нажата первый или второй раз.
- Если кнопка нажата первый раз ,то светодиоды включены, если второй - они выключаются.
* Для отслеживания состояния порта кнопки используется входной регистр данных IDR.
- Если состояние
порта Low, то переключаем светодиоды в High.
- Если состояние
порта High, то переключаем светодиоды в Low.

== *_Код программы:_*

[source,cpp]
----
#include "rccregisters.hpp"
#include "gpiocregisters.hpp"
#include <iostream>
#include "gpioaregisters.hpp"

bool flag=1;
int main()
{
RCC::CR::HSEON::On::Set();
while(!RCC::CR::HSERDY::Ready::IsSet())
{
}

RCC::CFGR::SW::Hse::Set();

while(!RCC::CFGR::SWS::Hse::IsSet())
{
}
RCC::CR::HSION::Off::Set();

RCC::PLLCFGR::PLLSRC::HseSource::Set();

RCC::PLLCFGR::PLLM0::Set(4U);
RCC::PLLCFGR::PLLN0::Set(50U);
RCC::PLLCFGR::PLLP0::Pllp6::Set();

RCC::CR::PLLON::On::Set();

while(RCC::CR::PLLRDY::Unclocked::IsSet())
{
}

RCC::CFGR::SW::Pll::Set();
while(!RCC::CFGR::SWS::Pll::IsSet())
{
}

RCC::AHB1ENR::GPIOCEN::Enable::Set();
RCC::AHB1ENR::GPIOAEN::Enable::Set();
GPIOC::MODER::MODER13::Input::Set();
GPIOC::MODER::MODER5::Output::Set();
GPIOC::MODER::MODER8::Output::Set();
GPIOC::MODER::MODER9::Output::Set();
GPIOA::MODER::MODER5::Output::Set();

while(1)
{
if(GPIOC::IDR::IDR13::Low::IsSet()&&flag)
{
flag=0;
if(GPIOC::ODR::ODR5::Low::IsSet())
{
GPIOC::BSRR::BS5::High::Write();
GPIOC::BSRR::BS9::High::Write();
GPIOC::BSRR::BS8::High::Write();
GPIOA::BSRR::BS5::High::Write();
}
else
{
GPIOC::BSRR::BR5::Low::Write();
GPIOC::BSRR::BR9::Low::Write();
GPIOC::BSRR::BR8::Low::Write();
GPIOA::BSRR::BR5::Low::Write();
}
}
if(GPIOC::IDR::IDR13::High::IsSet())
{
flag=1;
}
}

return 1 ;
}
----

== *_Результат работы программы:_*

image::https://github.com/musenzovakhomenko/laba4/blob/main/20201108_210425.gif[]